:py:mod:`casq.backends.pulse_backend`
=====================================

.. py:module:: casq.backends.pulse_backend

.. autoapi-nested-parse::

   Pulse backend.



Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   casq.backends.pulse_backend.PulseBackend




.. py:class:: PulseBackend(hamiltonian: casq.models.hamiltonian_model.HamiltonianModel, control: casq.models.control_model.ControlModel, seed: Optional[int] = None)


   PulseBackend class.

   Args:
       hamiltonian: Hamiltonian model.
       control: Control model.
       seed: Seed to use in random sampling. Defaults to None.

   .. py:class:: ODESolverMethod


      Bases: :py:obj:`str`, :py:obj:`enum.Enum`

      ODE solver methods.

      .. py:attribute:: QISKIT_DYNAMICS_RK4
         :value: 'RK4'

         

      .. py:attribute:: QISKIT_DYNAMICS_JAX_RK4
         :value: 'jax_RK4'

         

      .. py:attribute:: QISKIT_DYNAMICS_JAX_ODEINT
         :value: 'jax_odeint'

         

      .. py:attribute:: SCIPY_BDF
         :value: 'BDF'

         

      .. py:attribute:: SCIPY_DOP853
         :value: 'DOP853'

         

      .. py:attribute:: SCIPY_LSODA
         :value: 'LSODA'

         

      .. py:attribute:: SCIPY_RADAU
         :value: 'Radau'

         

      .. py:attribute:: SCIPY_RK23
         :value: 'RK23'

         

      .. py:attribute:: SCIPY_RK45
         :value: 'RK45'

         


   .. py:class:: Solution


      PulseBackend.Solution class.

      Args:
          circuit_name: Pulse circuit name.
          times: Time at which pulse backend was solved.
          qubits: Integer labels for selected qubits from system. Defaults to [0].
          times: Times at which solved.
          samples: Solution samples.
          counts: Solution counts.
          populations: Solution populations.
          states: Solution states.
          iq_data: Solution IQ points.
          avg_iq_data: Solution average IQ points.
          shots: Number of shots per experiment. Defaults to 1024.
          seed: Seed to use in random sampling. Defaults to None.
          is_success: Trie if solution was successful.
          timestamp: Posix timestamp.

      .. py:attribute:: circuit_name
         :type: str

         

      .. py:attribute:: qubits
         :type: list[int]

         

      .. py:attribute:: times
         :type: list[float]

         

      .. py:attribute:: samples
         :type: list[list[int]]

         

      .. py:attribute:: counts
         :type: list[dict[str, int]]

         

      .. py:attribute:: populations
         :type: list[dict[str, float]]

         

      .. py:attribute:: states
         :type: list[Union[qiskit.quantum_info.DensityMatrix, qiskit.quantum_info.Statevector]]

         

      .. py:attribute:: iq_data
         :type: list[list[tuple[float, float]]]

         

      .. py:attribute:: avg_iq_data
         :type: list[tuple[float, float]]

         

      .. py:attribute:: shots
         :type: int
         :value: 1024

         

      .. py:attribute:: seed
         :type: Optional[int]

         

      .. py:attribute:: is_success
         :type: bool
         :value: True

         

      .. py:attribute:: timestamp
         :type: float

         

      .. py:method:: plot_population(filename: Optional[str] = None, hidden: bool = False) -> matplotlib.axes.Axes

         PulseBackend.Solution.plot_population method.

         Plots populations from result.

         Args:
             filename: If filename is provided as path str, then figure is saved as png.
             hidden: If False, then plot is not displayed. Useful if method is used for saving only.

         Returns:
             :py:class:`matplotlib.axes.Axes`


      .. py:method:: plot_iq(time_index: Optional[int] = None, filename: Optional[str] = None, hidden: bool = False) -> matplotlib.axes.Axes

         PulseBackend.Solution.plot_iq method.

         Plots IQ points from result.

         Args:
             time_index: Time at which to plot IQ points.
             filename: If filename is provided as path str, then figure is saved as png.
             hidden: If False, then plot is not displayed. Useful if method is used for saving only.

         Returns:
             :py:class:`matplotlib.axes.Axes`


      .. py:method:: plot_iq_trajectory(filename: Optional[str] = None, hidden: bool = False) -> matplotlib.axes.Axes

         PulseBackend.Solution.plot_iq_trajectory method.

         Plots trajectory of average IQ points from result.

         Args:
             filename: If filename is provided as path str, then figure is saved as png.
             hidden: If False, then plot is not displayed. Useful if method is used for saving only.

         Returns:
             :py:class:`matplotlib.axes.Axes`


      .. py:method:: plot_trajectory(qubit: int = 0, filename: Optional[str] = None, hidden: bool = False) -> matplotlib.axes.Axes

         PulseBackend.Solution.plot_trajectory method.

         Plots statevector trajectory from result.

         Args:
             qubit: Qubit to plot trajectory of.
             filename: If filename is provided as path str, then figure is saved as png.
             hidden: If False, then plot is not displayed. Useful if method is used for saving only.

         Returns:
             :py:class:`matplotlib.axes.Axes`


      .. py:method:: plot_bloch_trajectory(qubit: int = 0, filename: Optional[str] = None, hidden: bool = False) -> mpl_toolkits.mplot3d.Axes3D

         PulseBackend.Solution.plot_bloch_trajectory method.

         Plots statevector trajectory on Bloch sphere from result.

         Args:
             qubit: Qubit to plot trajectory of.
             filename: If filename is provided as path str, then figure is saved as png.
             hidden: If False, then plot is not displayed. Useful if method is used for saving only.

         Returns:
             :py:class:`mpl_toolkits.mplot3d.Axes3D`


      .. py:method:: _xyz(qubit: int = 0) -> tuple[list[float], list[float], list[float]]

         PulseBackend.Solution._xyz method.

         Transforms statevectors into 3D trajectory from result.

         Returns:
             XYZ data lists or dict of lists.


      .. py:method:: _trace(state: qiskit.quantum_info.Statevector, qubit: int) -> qiskit.quantum_info.Statevector

         PulseBackend.Solution._trace method.

         Generate partial trace of statevector for specified qubit.

         Args:
             state: System state given as statevector.
             qubit: Qubit to trace out.

         Returns:
             Reduced :py:class:`qiskit.quantum_info.Statevector`



   .. py:method:: solve(circuit: casq.gates.pulse_circuit.PulseCircuit, method: ODESolverMethod, initial_state: Optional[Union[qiskit.quantum_info.DensityMatrix, qiskit.quantum_info.Statevector]] = None, shots: int = 1024, steps: Optional[int] = None, run_options: Optional[dict[str, Any]] = None) -> PulseBackend
      :abstractmethod:

      PulseBackend.solve.

      Args:
          circuit: Pulse circuit.
          method: ODE solving method to use.
          initial_state: Initial state for simulation,
              either None,
              indicating that the ground state for the system Hamiltonian should be used,
              or an arbitrary Statevector or DensityMatrix.
          shots: Number of shots per experiment. Defaults to 1024.
          steps: Number of steps at which to solve the system.
              Used to automatically calculate an evenly-spaced t_eval range.
          run_options: Options specific to native backend's run method.

      Returns:
          :py:class:`casq.backends.PulseBackend.Solution`


   .. py:method:: _get_native_backend() -> Any
      :abstractmethod:

      PulseBackend._get_native_backend.

      Returns:
          Any



