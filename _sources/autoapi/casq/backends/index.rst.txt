:py:mod:`casq.backends`
=======================

.. py:module:: casq.backends

.. autoapi-nested-parse::

   Collecting casq.backends package imports in one place for convenient access.



Subpackages
-----------
.. toctree::
   :titlesonly:
   :maxdepth: 3

   qiskit/index.rst


Submodules
----------
.. toctree::
   :titlesonly:
   :maxdepth: 1

   helpers/index.rst
   pulse_backend/index.rst


Package Contents
----------------

Classes
~~~~~~~

.. autoapisummary::

   casq.backends.BackendLibrary
   casq.backends.PulseBackend
   casq.backends.BackendCharacteristics
   casq.backends.DynamicsBackendPatch
   casq.backends.QiskitPulseBackend



Functions
~~~~~~~~~

.. autoapisummary::

   casq.backends.build
   casq.backends.build_from_backend
   casq.backends.convert_to_solution
   casq.backends.get_experiment_result



.. py:class:: BackendLibrary(*args, **kwds)


   Bases: :py:obj:`enum.Enum`

   Backend library.

   .. py:attribute:: C3
      :value: 0

      

   .. py:attribute:: QISKIT
      :value: 1

      

   .. py:attribute:: QUTIP
      :value: 2

      


.. py:function:: build(backend_library, hamiltonian, control, seed = None)

   Build PulseBackend.

       Currently, only supports Qiskit.

   Args:
       backend_library: Backend library.
       hamiltonian: Hamiltonian model.
       control: Control model.
       seed: Seed to use in random sampling. Defaults to None.

   Returns:
       QiskitPulseBackend


.. py:function:: build_from_backend(backend, extracted_qubits = None, rotating_frame = None, in_frame_basis = False, evaluation_mode = None, rwa_cutoff_freq = None, rwa_carrier_freqs = None, seed = None)

   Build PulseBackend from library-specific backend.

   Currently, only supports Qiskit.

   Args:
       backend: The ``Backend`` instance to build the :class:`.DynamicsBackend` from.
       extracted_qubits: List of qubits to extract from the Hamiltonian.
       rotating_frame: Rotating frame argument for the internal :class:`.Solver`.
               Defaults to None, allowing this method to pick a rotating frame.
       in_frame_basis: Whether to represent the model in the basis in which
                       the rotating frame operator is diagonalized.
       evaluation_mode: Evaluation mode to use by solver.
       rwa_cutoff_freq: Rotating wave approximation cutoff frequency.
                       If None, no approximation is made.
       rwa_carrier_freqs: Carrier frequencies to use for rotating wave approximation.
       seed: Seed to use in random sampling. Defaults to None.

   Returns:
       QiskitPulseBackend


.. py:class:: PulseBackend(hamiltonian, control, seed = None)


   PulseBackend class.

   .. py:class:: ODESolverMethod


      Bases: :py:obj:`str`, :py:obj:`enum.Enum`

      Solver methods.

      .. py:attribute:: QISKIT_DYNAMICS_RK4
         :value: 'RK4'

         

      .. py:attribute:: QISKIT_DYNAMICS_JAX_RK4
         :value: 'jax_RK4'

         

      .. py:attribute:: QISKIT_DYNAMICS_JAX_ODEINT
         :value: 'jax_odeint'

         

      .. py:attribute:: SCIPY_BDF
         :value: 'BDF'

         

      .. py:attribute:: SCIPY_DOP853
         :value: 'DOP853'

         

      .. py:attribute:: SCIPY_LSODA
         :value: 'LSODA'

         

      .. py:attribute:: SCIPY_RADAU
         :value: 'Radau'

         

      .. py:attribute:: SCIPY_RK23
         :value: 'RK23'

         

      .. py:attribute:: SCIPY_RK45
         :value: 'RK45'

         


   .. py:class:: Solution(circuit_name, qubits, times, samples, counts, populations, states, iq_data, avg_iq_data, shots = 1024, seed = None, is_success = True, timestamp = datetime.timestamp(datetime.now()))


      PulseBackend.Solution class.

      .. py:method:: plot_population(filename = None, hidden = False)

         PulseBackend.Solution.plot_population method.

         Plots populations from result.

         Args:
             filename: If filename is provided as path str, then figure is saved as png.
             hidden: If False, then plot is not displayed. Useful if method is used for saving only.

         Returns:
             Matplotlib Axes.


      .. py:method:: plot_iq(time_index = None, filename = None, hidden = False)

         PulseBackend.Solution.plot_iq method.

         Plots IQ points from result.

         Args:
             time_index: Time at which to plot IQ points.
             filename: If filename is provided as path str, then figure is saved as png.
             hidden: If False, then plot is not displayed. Useful if method is used for saving only.

         Returns:
             Matplotlib Axes.


      .. py:method:: plot_iq_trajectory(filename = None, hidden = False)

         PulseBackend.Solution.plot_iq_trajectory method.

         Plots trajectory of average IQ points from result.

         Args:
             filename: If filename is provided as path str, then figure is saved as png.
             hidden: If False, then plot is not displayed. Useful if method is used for saving only.

         Returns:
             Matplotlib Axes.


      .. py:method:: plot_trajectory(qubit = 0, filename = None, hidden = False)

         PulseBackend.Solution.plot_trajectory method.

         Plots statevector trajectory from result.

         Args:
             qubit: Qubit to plot trajectory of.
             filename: If filename is provided as path str, then figure is saved as png.
             hidden: If False, then plot is not displayed. Useful if method is used for saving only.

         Returns:
             Matplotlib Axes.


      .. py:method:: plot_bloch_trajectory(qubit = 0, filename = None, hidden = False)

         PulseBackend.Solution.plot_bloch_trajectory method.

         Plots statevector trajectory on Bloch sphere from result.

         Args:
             qubit: Qubit to plot trajectory of.
             filename: If filename is provided as path str, then figure is saved as png.
             hidden: If False, then plot is not displayed. Useful if method is used for saving only.

         Returns:
             Matplotlib Axes.


      .. py:method:: _xyz(qubit = 0)

         PulseBackend.Solution._xyz method.

         Transforms statevectors into 3D trajectory from result.

         Returns:
             XYZ data lists or dict of lists.


      .. py:method:: _trace(state, qubit)

         PulseBackend.Solution._trace method.

         Generate partial trace of statevector for specified qubit.

         Args:
             state: System state given as statevector.
             qubit: Qubit to trace out.

         Returns:
             Reduced statevector.



   .. py:method:: solve(circuit, method, initial_state = None, shots = 1024, steps = None, run_options = None)
      :abstractmethod:

      PulseBackend.run.

      Args:
          circuit: Pulse circuit.
          method: ODE solving method to use.
          initial_state: Initial state for simulation,
              either None,
              indicating that the ground state for the system Hamiltonian should be used,
              or an arbitrary Statevector or DensityMatrix.
          shots: Number of shots per experiment. Defaults to 1024.
          steps: Number of steps at which to solve the system.
              Used to automatically calculate an evenly-spaced t_eval range.
          run_options: Options specific to native backend's run method.


   .. py:method:: _get_native_backend()
      :abstractmethod:

      PulseBackend._get_native_backend.



.. py:class:: BackendCharacteristics(backend)


   BackendCharacteristics class.

   Extracts IBMQ backend characteristics needed by various casq classes and methods.
   Requires PulseBackendConfiguration with valid configuration, properties, and defaults.

   BackendV2 currently lacks all necessary characteristics
   that may be utilized by a PulseBackend.
   However, this may change in future Qiskit versions.

   Args:
       backend: IBMQ backend compatible with BackendV1.

   .. py:class:: GateProperties


      Bases: :py:obj:`NamedTuple`

      Gate properties.

      .. py:attribute:: gate_error
         :type: float

         

      .. py:attribute:: gate_length
         :type: float

         

      .. py:attribute:: qubits
         :type: list[int]

         

      .. py:attribute:: parameters
         :type: dict[str, Any]

         

      .. py:attribute:: is_operational
         :type: bool

         


   .. py:class:: QubitProperties


      Bases: :py:obj:`NamedTuple`

      Qubit properties.

      .. py:attribute:: frequency
         :type: float

         

      .. py:attribute:: readout_error
         :type: float

         

      .. py:attribute:: readout_length
         :type: float

         

      .. py:attribute:: t1
         :type: float

         

      .. py:attribute:: t2
         :type: float

         

      .. py:attribute:: is_operational
         :type: bool

         


   .. py:method:: get_backend(name)
      :staticmethod:

      BackendCharacteristics._get_backend method.

      Returns:
          :py:class:`qiskit.providers.Backend`


   .. py:method:: get_qubit_properties(qubit)

      BackendCharacteristics.get_qubit_properties method.

      Args:
          qubit: Qubit to attach gate to.

      Returns:
          :py:class:`casq.backends.qiskit.BackendCharacteristics.QubitProperties`


   .. py:method:: get_gate_properties(gate_name)

      BackendCharacteristics.get_gate_properties method.

      Args:
          gate_name: Gate name.

      Returns:
          :py:class:`casq.backends.qiskit.BackendCharacteristics.GateProperties`


   .. py:method:: _get_config()

      BackendCharacteristics._get_config method.

      Returns:
          :py:class:`qiskit.providers.models.PulseBackendConfiguration`


   .. py:method:: _get_defaults()

      BackendCharacteristics._get_defaults method.

      Returns:
          :py:class:`qiskit.providers.models.PulseDefaults`


   .. py:method:: _get_properties()

      BackendCharacteristics._get_properties method.

      Returns:
          :py:class:`qiskit.providers.models.BackendProperties`


   .. py:method:: get_channel_frequencies(channels)

      Discretizes pulse schedule into signals.

      Args:
          channels: List of channel names or channel instances.

      Returns:
          List of :py:class:`qiskit_dynamics.signals.Signal`


   .. py:method:: get_control_channel_map(channels_filter)

      Get control channel map from backend configuration.

      Args:
          channels_filter: List of channel names to filter by.

      Returns:
          Dictionary mapping qubits to control channels.



.. py:class:: DynamicsBackendPatch(solver, target = None, **options)


   Bases: :py:obj:`qiskit_dynamics.backend.DynamicsBackend`

   DynamicsBackend patch class.

   This class extends :class:`~qiskit.qiskit_dynamics.DynamicsBackend`
   to provide the following improvements.
   - Solutions are calculated for each t_eval point,
       however intermediate solutions are not stored in the result object.
       This bug is now fixed.
   - t_eval must be provided without knowing the internally calculated t_span range.
       Furthermore, manually entering t_span causes an error. As a result,
       providing a t_eval range is awkward at best and error-prone.
       As an alternative, automatic calculation of t_eval range
       based on a steps argument is now provided.

   .. py:class:: Options


      Qiskit dynamics backend options.

      .. py:attribute:: shots
         :type: int
         :value: 1024

         

      .. py:attribute:: solver
         :type: Optional[qiskit_dynamics.Solver]

         

      .. py:attribute:: solver_options
         :type: dict[str, Any]

         

      .. py:attribute:: subsystem_labels
         :type: Optional[list[int]]

         

      .. py:attribute:: subsystem_dims
         :type: Optional[list[int]]

         

      .. py:attribute:: meas_map
         :type: Optional[dict]

         

      .. py:attribute:: control_channel_map
         :type: Optional[dict]

         

      .. py:attribute:: normalize_states
         :type: bool
         :value: True

         

      .. py:attribute:: initial_state
         :type: Union[str, qiskit.quantum_info.DensityMatrix, qiskit.quantum_info.Statevector]
         :value: 'ground_state'

         

      .. py:attribute:: meas_level
         :type: qiskit.qobj.utils.MeasLevel

         

      .. py:attribute:: meas_return
         :type: qiskit.qobj.utils.MeasReturnType

         

      .. py:attribute:: iq_centers
         :type: Optional[list[list[list[float]]]]

         

      .. py:attribute:: iq_width
         :type: float
         :value: 0.2

         

      .. py:attribute:: max_outcome_level
         :type: Optional[int]
         :value: 1

         

      .. py:attribute:: memory
         :type: bool
         :value: True

         

      .. py:attribute:: seed_simulator
         :type: Optional[int]

         

      .. py:attribute:: experiment_result_function
         :type: Callable

         

      .. py:attribute:: configuration
         :type: Optional[qiskit.providers.models.PulseBackendConfiguration]

         

      .. py:attribute:: defaults
         :type: Optional[qiskit.providers.models.PulseDefaults]

         

      .. py:method:: to_dict()

         Converts to dict.



   .. py:method:: from_backend(backend, qubits = None, rotating_frame = 'auto', evaluation_mode = 'dense', rwa_cutoff_freq = None, **options)
      :classmethod:

      Construct a DynamicsBackendPatch instance from an existing Backend instance.

      Args:
          backend: The ``Backend`` instance to build the :class:`.DynamicsBackend` from.
          qubits: List of qubits to include from the backend.
          rotating_frame: Rotating frame argument for the internal :class:`.Solver`. Defaults to
              ``"auto"``, allowing this method to pick a rotating frame.
          evaluation_mode: Evaluation mode argument for the internal :class:`.Solver`.
          rwa_cutoff_freq: Rotating wave approximation argument for the internal :class:`.Solver`.
          options: Additional configuration options for the backend.

      Returns:
          DynamicsBackendPatch

      Raises:
          QiskitError: If any required parameters are missing from the passed backend.


   .. py:method:: _run(job_id, t_span, schedules, measurement_subsystems_list, memory_slot_indices_list, num_memory_slots_list)

      Run a list of simulations.

      Args:
          job_id: Job identifier.
          t_span: Tuple or list of initial and final time.
          schedules: List of schedules.
          measurement_subsystems_list: List of measurement subsystems.
          memory_slot_indices_list: List of memory slot indices.
          num_memory_slots_list: List of numbers of memory slots.

      Returns:
          ExperimentResult object.



.. py:function:: convert_to_solution(result)

   Converts Qiskit result to pulse backend solution.

   Args:
       result: Qiskit experiment result.

   Returns:
       Pulse solution.


.. py:function:: get_experiment_result(experiment_name, solver_result, measurement_subsystems, memory_slot_indices, num_memory_slots, backend, seed = None, metadata = None)

   Generates ExperimentResult objects from solver result.

   Args:
       experiment_name: Name of experiment.
       solver_result: Result object from :class:`Solver.solve`.
       measurement_subsystems: Labels of subsystems in the model being measured.
       memory_slot_indices: Indices of memory slots
           to store the results in for each subsystem.
       num_memory_slots: Total number of memory slots in the returned output.
           If ``None``, ``max(memory_slot_indices)`` will be used.
       backend: The backend instance that ran the simulation.
           Various options and properties are utilized.
       seed: Seed for any random number generation involved
           (e.g. when computing outcome samples).
       metadata: Metadata to add to the header of the
           :class:`~qiskit.result.models.ExperimentResult` object.

   Returns:
       :class:`~qiskit.result.models.ExperimentResult`

   Raises:
       QiskitError: If a specified option is unsupported.


.. py:class:: QiskitPulseBackend(hamiltonian, control, seed = None)


   Bases: :py:obj:`casq.backends.pulse_backend.PulseBackend`

   QiskitPulseBackend class.

   .. py:method:: from_backend(backend, extracted_qubits = None, rotating_frame = None, in_frame_basis = False, evaluation_mode = None, rwa_cutoff_freq = None, rwa_carrier_freqs = None, seed = None)
      :classmethod:

      Construct a QiskitPulseBackend instance from an existing backend instance.

      Args:
          backend: The ``Backend`` instance to build the :class:`.DynamicsBackend` from.
          extracted_qubits: List of qubits to extract from the Hamiltonian.
          rotating_frame: Rotating frame argument for the internal :class:`.Solver`.
                  Defaults to None, allowing this method to pick a rotating frame.
          in_frame_basis: Whether to represent the model in the basis in which
                          the rotating frame operator is diagonalized.
          evaluation_mode: Evaluation mode to use by solver.
          rwa_cutoff_freq: Rotating wave approximation cutoff frequency.
                          If None, no approximation is made.
          rwa_carrier_freqs: Carrier frequencies to use for rotating wave approximation.
          seed: Seed to use in random sampling. Defaults to None.

      Returns:
          QiskitPulseBackend


   .. py:method:: solve(circuit, method, initial_state = None, shots = 1024, steps = None, run_options = None)

      QiskitPulseBackend.run.


   .. py:method:: _get_native_backend()

      QiskitPulseBackend._get_native_backend.



