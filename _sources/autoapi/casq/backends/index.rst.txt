:py:mod:`casq.backends`
=======================

.. py:module:: casq.backends

.. autoapi-nested-parse::

   Collecting casq.backends package imports in one place for convenient access.



Subpackages
-----------
.. toctree::
   :titlesonly:
   :maxdepth: 3

   qiskit/index.rst


Submodules
----------
.. toctree::
   :titlesonly:
   :maxdepth: 1

   helpers/index.rst
   pulse_backend/index.rst


Package Contents
----------------

Classes
~~~~~~~

.. autoapisummary::

   casq.backends.BackendLibrary
   casq.backends.PulseBackend
   casq.backends.BackendCharacteristics
   casq.backends.DynamicsBackendPatch
   casq.backends.QiskitPulseBackend



Functions
~~~~~~~~~

.. autoapisummary::

   casq.backends.build
   casq.backends.build_from_backend
   casq.backends.convert_to_solution
   casq.backends.get_experiment_result



.. py:class:: BackendLibrary(*args, **kwds)


   Bases: :py:obj:`enum.Enum`

   Backend library.

   .. py:attribute:: C3
      :value: 0

      

   .. py:attribute:: QISKIT
      :value: 1

      

   .. py:attribute:: QUTIP
      :value: 2

      


.. py:function:: build(backend_library: BackendLibrary, hamiltonian: casq.models.hamiltonian_model.HamiltonianModel, control: casq.models.control_model.ControlModel, seed: Optional[int] = None) -> casq.backends.qiskit.qiskit_pulse_backend.QiskitPulseBackend

   Build PulseBackend.

   Currently, only supports Qiskit.

   Args:
       backend_library: Backend library.
       hamiltonian: Hamiltonian model.
       control: Control model.
       seed: Seed to use in random sampling. Defaults to None.

   Returns:
       :py:class:`casq.backends.qiskit.QiskitPulseBackend`


.. py:function:: build_from_backend(backend: qiskit.providers.Backend, extracted_qubits: Optional[list[int]] = None, rotating_frame: Optional[Union[qiskit_dynamics.array.Array, qiskit_dynamics.RotatingFrame]] = None, in_frame_basis: bool = False, evaluation_mode: Optional[casq.models.hamiltonian_model.HamiltonianModel.EvaluationMode] = None, rwa_cutoff_freq: Optional[float] = None, rwa_carrier_freqs: Optional[Union[numpy.typing.NDArray, tuple[numpy.typing.NDArray, numpy.typing.NDArray]]] = None, seed: Optional[int] = None) -> casq.backends.qiskit.qiskit_pulse_backend.QiskitPulseBackend

   Build PulseBackend from library-specific backend.

   Currently, only supports Qiskit.

   Args:
       backend: The ``Backend`` instance to build the :class:`.DynamicsBackend` from.
       extracted_qubits: List of qubits to extract from the Hamiltonian.
       rotating_frame: Rotating frame argument for the internal :class:`.Solver`.
               Defaults to None, allowing this method to pick a rotating frame.
       in_frame_basis: Whether to represent the model in the basis in which
                       the rotating frame operator is diagonalized.
       evaluation_mode: Evaluation mode to use by solver.
       rwa_cutoff_freq: Rotating wave approximation cutoff frequency.
                       If None, no approximation is made.
       rwa_carrier_freqs: Carrier frequencies to use for rotating wave approximation.
       seed: Seed to use in random sampling. Defaults to None.

   Returns:
       :py:class:`casq.backends.qiskit.QiskitPulseBackend`


.. py:class:: PulseBackend(hamiltonian: casq.models.hamiltonian_model.HamiltonianModel, control: casq.models.control_model.ControlModel, seed: Optional[int] = None)


   PulseBackend class.

   Args:
       hamiltonian: Hamiltonian model.
       control: Control model.
       seed: Seed to use in random sampling. Defaults to None.

   .. py:class:: ODESolverMethod


      Bases: :py:obj:`str`, :py:obj:`enum.Enum`

      ODE solver methods.

      .. py:attribute:: QISKIT_DYNAMICS_RK4
         :value: 'RK4'

         

      .. py:attribute:: QISKIT_DYNAMICS_JAX_RK4
         :value: 'jax_RK4'

         

      .. py:attribute:: QISKIT_DYNAMICS_JAX_ODEINT
         :value: 'jax_odeint'

         

      .. py:attribute:: SCIPY_BDF
         :value: 'BDF'

         

      .. py:attribute:: SCIPY_DOP853
         :value: 'DOP853'

         

      .. py:attribute:: SCIPY_LSODA
         :value: 'LSODA'

         

      .. py:attribute:: SCIPY_RADAU
         :value: 'Radau'

         

      .. py:attribute:: SCIPY_RK23
         :value: 'RK23'

         

      .. py:attribute:: SCIPY_RK45
         :value: 'RK45'

         


   .. py:class:: Solution


      PulseBackend.Solution class.

      Args:
          circuit_name: Pulse circuit name.
          times: Time at which pulse backend was solved.
          qubits: Integer labels for selected qubits from system. Defaults to [0].
          times: Times at which solved.
          samples: Solution samples.
          counts: Solution counts.
          populations: Solution populations.
          states: Solution states.
          iq_data: Solution IQ points.
          avg_iq_data: Solution average IQ points.
          shots: Number of shots per experiment. Defaults to 1024.
          seed: Seed to use in random sampling. Defaults to None.
          is_success: Trie if solution was successful.
          timestamp: Posix timestamp.

      .. py:attribute:: circuit_name
         :type: str

         

      .. py:attribute:: qubits
         :type: list[int]

         

      .. py:attribute:: times
         :type: list[float]

         

      .. py:attribute:: samples
         :type: list[list[int]]

         

      .. py:attribute:: counts
         :type: list[dict[str, int]]

         

      .. py:attribute:: populations
         :type: list[dict[str, float]]

         

      .. py:attribute:: states
         :type: list[Union[qiskit.quantum_info.DensityMatrix, qiskit.quantum_info.Statevector]]

         

      .. py:attribute:: iq_data
         :type: list[list[tuple[float, float]]]

         

      .. py:attribute:: avg_iq_data
         :type: list[tuple[float, float]]

         

      .. py:attribute:: shots
         :type: int
         :value: 1024

         

      .. py:attribute:: seed
         :type: Optional[int]

         

      .. py:attribute:: is_success
         :type: bool
         :value: True

         

      .. py:attribute:: timestamp
         :type: float

         

      .. py:method:: plot_population(filename: Optional[str] = None, hidden: bool = False) -> matplotlib.axes.Axes

         PulseBackend.Solution.plot_population method.

         Plots populations from result.

         Args:
             filename: If filename is provided as path str, then figure is saved as png.
             hidden: If False, then plot is not displayed. Useful if method is used for saving only.

         Returns:
             :py:class:`matplotlib.axes.Axes`


      .. py:method:: plot_iq(time_index: Optional[int] = None, filename: Optional[str] = None, hidden: bool = False) -> matplotlib.axes.Axes

         PulseBackend.Solution.plot_iq method.

         Plots IQ points from result.

         Args:
             time_index: Time at which to plot IQ points.
             filename: If filename is provided as path str, then figure is saved as png.
             hidden: If False, then plot is not displayed. Useful if method is used for saving only.

         Returns:
             :py:class:`matplotlib.axes.Axes`


      .. py:method:: plot_iq_trajectory(filename: Optional[str] = None, hidden: bool = False) -> matplotlib.axes.Axes

         PulseBackend.Solution.plot_iq_trajectory method.

         Plots trajectory of average IQ points from result.

         Args:
             filename: If filename is provided as path str, then figure is saved as png.
             hidden: If False, then plot is not displayed. Useful if method is used for saving only.

         Returns:
             :py:class:`matplotlib.axes.Axes`


      .. py:method:: plot_trajectory(qubit: int = 0, filename: Optional[str] = None, hidden: bool = False) -> matplotlib.axes.Axes

         PulseBackend.Solution.plot_trajectory method.

         Plots statevector trajectory from result.

         Args:
             qubit: Qubit to plot trajectory of.
             filename: If filename is provided as path str, then figure is saved as png.
             hidden: If False, then plot is not displayed. Useful if method is used for saving only.

         Returns:
             :py:class:`matplotlib.axes.Axes`


      .. py:method:: plot_bloch_trajectory(qubit: int = 0, filename: Optional[str] = None, hidden: bool = False) -> mpl_toolkits.mplot3d.Axes3D

         PulseBackend.Solution.plot_bloch_trajectory method.

         Plots statevector trajectory on Bloch sphere from result.

         Args:
             qubit: Qubit to plot trajectory of.
             filename: If filename is provided as path str, then figure is saved as png.
             hidden: If False, then plot is not displayed. Useful if method is used for saving only.

         Returns:
             :py:class:`mpl_toolkits.mplot3d.Axes3D`


      .. py:method:: _xyz(qubit: int = 0) -> tuple[list[float], list[float], list[float]]

         PulseBackend.Solution._xyz method.

         Transforms statevectors into 3D trajectory from result.

         Returns:
             XYZ data lists or dict of lists.


      .. py:method:: _trace(state: qiskit.quantum_info.Statevector, qubit: int) -> qiskit.quantum_info.Statevector

         PulseBackend.Solution._trace method.

         Generate partial trace of statevector for specified qubit.

         Args:
             state: System state given as statevector.
             qubit: Qubit to trace out.

         Returns:
             Reduced :py:class:`qiskit.quantum_info.Statevector`



   .. py:method:: solve(circuit: casq.gates.pulse_circuit.PulseCircuit, method: ODESolverMethod, initial_state: Optional[Union[qiskit.quantum_info.DensityMatrix, qiskit.quantum_info.Statevector]] = None, shots: int = 1024, steps: Optional[int] = None, run_options: Optional[dict[str, Any]] = None) -> PulseBackend
      :abstractmethod:

      PulseBackend.solve.

      Args:
          circuit: Pulse circuit.
          method: ODE solving method to use.
          initial_state: Initial state for simulation,
              either None,
              indicating that the ground state for the system Hamiltonian should be used,
              or an arbitrary Statevector or DensityMatrix.
          shots: Number of shots per experiment. Defaults to 1024.
          steps: Number of steps at which to solve the system.
              Used to automatically calculate an evenly-spaced t_eval range.
          run_options: Options specific to native backend's run method.

      Returns:
          :py:class:`casq.backends.PulseBackend.Solution`


   .. py:method:: _get_native_backend() -> Any
      :abstractmethod:

      PulseBackend._get_native_backend.

      Returns:
          Any



.. py:class:: BackendCharacteristics(backend: Union[str, qiskit.providers.Backend])


   BackendCharacteristics class.

   Extracts IBMQ backend characteristics needed by various casq classes and methods.
   Requires PulseBackendConfiguration with valid configuration, properties, and defaults.

   BackendV2 currently lacks all necessary characteristics
   that may be utilized by a PulseBackend.
   However, this may change in future Qiskit versions.

   Args:
       backend: IBMQ backend compatible with BackendV1.

   .. py:class:: GateProperties


      Bases: :py:obj:`NamedTuple`

      Gate properties.

      .. py:attribute:: gate_error
         :type: float

         

      .. py:attribute:: gate_length
         :type: float

         

      .. py:attribute:: qubits
         :type: list[int]

         

      .. py:attribute:: parameters
         :type: dict[str, Any]

         

      .. py:attribute:: is_operational
         :type: bool

         


   .. py:class:: QubitProperties


      Bases: :py:obj:`NamedTuple`

      Qubit properties.

      .. py:attribute:: frequency
         :type: float

         

      .. py:attribute:: readout_error
         :type: float

         

      .. py:attribute:: readout_length
         :type: float

         

      .. py:attribute:: t1
         :type: float

         

      .. py:attribute:: t2
         :type: float

         

      .. py:attribute:: is_operational
         :type: bool

         


   .. py:method:: get_backend(name: str) -> qiskit.providers.Backend
      :staticmethod:

      BackendCharacteristics._get_backend method.

      Returns:
          :py:class:`qiskit.providers.Backend`


   .. py:method:: get_qubit_properties(qubit: int) -> QubitProperties

      BackendCharacteristics.get_qubit_properties method.

      Args:
          qubit: Qubit to attach gate to.

      Returns:
          :py:class:`casq.backends.qiskit.BackendCharacteristics.QubitProperties`


   .. py:method:: get_gate_properties(gate_name: str) -> GateProperties

      BackendCharacteristics.get_gate_properties method.

      Args:
          gate_name: Gate name.

      Returns:
          :py:class:`casq.backends.qiskit.BackendCharacteristics.GateProperties`


   .. py:method:: _get_config() -> qiskit.providers.models.PulseBackendConfiguration

      BackendCharacteristics._get_config method.

      Returns:
          :py:class:`qiskit.providers.models.PulseBackendConfiguration`


   .. py:method:: _get_defaults() -> qiskit.providers.models.PulseDefaults

      BackendCharacteristics._get_defaults method.

      Returns:
          :py:class:`qiskit.providers.models.PulseDefaults`


   .. py:method:: _get_properties() -> qiskit.providers.models.BackendProperties

      BackendCharacteristics._get_properties method.

      Returns:
          :py:class:`qiskit.providers.models.BackendProperties`


   .. py:method:: get_channel_frequencies(channels: Union[list[str], list[qiskit.pulse.channels.Channel]]) -> dict[str, float]

      Discretizes pulse schedule into signals.

      Args:
          channels: List of channel names or channel instances.

      Returns:
          List of :py:class:`qiskit_dynamics.signals.Signal`


   .. py:method:: get_control_channel_map(channels_filter: list[str]) -> dict[tuple[int, Ellipsis], int]

      Get control channel map from backend configuration.

      Args:
          channels_filter: List of channel names to filter by.

      Returns:
          Dictionary mapping qubits to control channels.



.. py:class:: DynamicsBackendPatch(solver: qiskit_dynamics.Solver, target: Optional[qiskit.transpiler.Target] = None, **options: Any)


   Bases: :py:obj:`qiskit_dynamics.backend.DynamicsBackend`

   DynamicsBackend patch class.

   This class extends :class:`~qiskit.qiskit_dynamics.DynamicsBackend`
   to provide the following improvements.
   - Solutions are calculated for each t_eval point,
       however intermediate solutions are not stored in the result object.
       This bug is now fixed.
   - t_eval must be provided without knowing the internally calculated t_span range.
       Furthermore, manually entering t_span causes an error. As a result,
       providing a t_eval range is awkward at best and error-prone.
       As an alternative, automatic calculation of t_eval range
       based on a steps argument is now provided.

   Args:
       solver: Solver instance configured for pulse simulation.
       target: Target object.
       steps: Number of steps at which to solve the system.
           Used to automatically calculate an evenly-spaced t_eval range.
       options: Additional configuration options for the backend.

   Raises:
       If any instantiation arguments fail validation checks,
       then raises :py:class:`~qiskit.exceptions.QiskitError`.

   .. py:class:: Options


      Qiskit dynamics backend options.

      .. py:attribute:: shots
         :type: int
         :value: 1024

         

      .. py:attribute:: solver
         :type: Optional[qiskit_dynamics.Solver]

         

      .. py:attribute:: solver_options
         :type: dict[str, Any]

         

      .. py:attribute:: subsystem_labels
         :type: Optional[list[int]]

         

      .. py:attribute:: subsystem_dims
         :type: Optional[list[int]]

         

      .. py:attribute:: meas_map
         :type: Optional[dict]

         

      .. py:attribute:: control_channel_map
         :type: Optional[dict]

         

      .. py:attribute:: normalize_states
         :type: bool
         :value: True

         

      .. py:attribute:: initial_state
         :type: Union[str, qiskit.quantum_info.DensityMatrix, qiskit.quantum_info.Statevector]
         :value: 'ground_state'

         

      .. py:attribute:: meas_level
         :type: qiskit.qobj.utils.MeasLevel

         

      .. py:attribute:: meas_return
         :type: qiskit.qobj.utils.MeasReturnType

         

      .. py:attribute:: iq_centers
         :type: Optional[list[list[list[float]]]]

         

      .. py:attribute:: iq_width
         :type: float
         :value: 0.2

         

      .. py:attribute:: max_outcome_level
         :type: Optional[int]
         :value: 1

         

      .. py:attribute:: memory
         :type: bool
         :value: True

         

      .. py:attribute:: seed_simulator
         :type: Optional[int]

         

      .. py:attribute:: experiment_result_function
         :type: Callable

         

      .. py:attribute:: configuration
         :type: Optional[qiskit.providers.models.PulseBackendConfiguration]

         

      .. py:attribute:: defaults
         :type: Optional[qiskit.providers.models.PulseDefaults]

         

      .. py:method:: to_dict() -> dict[str, Any]

         Converts to dict.

         Returns:
             Dictionary.



   .. py:method:: from_backend(backend: Union[qiskit.providers.BackendV1, qiskit.providers.BackendV2], qubits: Optional[list[int]] = None, rotating_frame: Union[qiskit_dynamics.array.Array, qiskit_dynamics.RotatingFrame, str] = 'auto', evaluation_mode: str = 'dense', rwa_cutoff_freq: Optional[float] = None, **options: Any) -> DynamicsBackendPatch
      :classmethod:

      Construct a DynamicsBackendPatch instance from an existing Backend instance.

      Args:
          backend: The ``Backend`` instance to build the :class:`.DynamicsBackend` from.
          qubits: List of qubits to include from the backend.
          rotating_frame: Rotating frame argument for the internal :class:`.Solver`. Defaults to
              ``"auto"``, allowing this method to pick a rotating frame.
          evaluation_mode: Evaluation mode argument for the internal :class:`.Solver`.
          rwa_cutoff_freq: Rotating wave approximation argument for the internal :class:`.Solver`.
          options: Additional configuration options for the backend.

      Returns:
          DynamicsBackendPatch

      Raises:
          If any required parameters are missing from the passed backend,
          then raises :py:class:`~qiskit.exceptions.QiskitError`.


   .. py:method:: _run(job_id: str, t_span: Union[list[tuple[float, float]], list[list[float]]], schedules: list[qiskit.pulse.Schedule], measurement_subsystems_list: list[list[int]], memory_slot_indices_list: list[list[int]], num_memory_slots_list: list[int]) -> qiskit.result.Result

      Run a list of simulations.

      Args:
          job_id: Job identifier.
          t_span: Tuple or list of initial and final time.
          schedules: List of schedules.
          measurement_subsystems_list: List of measurement subsystems.
          memory_slot_indices_list: List of memory slot indices.
          num_memory_slots_list: List of numbers of memory slots.

      Returns:
          ExperimentResult object.



.. py:function:: convert_to_solution(result: qiskit.result.models.ExperimentResult) -> casq.backends.pulse_backend.PulseBackend.Solution

   Converts Qiskit result to pulse backend solution.

   Args:
       result: Qiskit experiment result.

   Returns:
       :py:class:`casq.backends.PulseBackend.Solution`


.. py:function:: get_experiment_result(experiment_name: str, solver_result: scipy.integrate._ivp.ivp.OdeResult, measurement_subsystems: list[int], memory_slot_indices: list[int], num_memory_slots: Union[None, int], backend: qiskit_dynamics.backend.DynamicsBackend, seed: Optional[int] = None, metadata: Optional[dict] = None) -> qiskit.result.models.ExperimentResult

   Generates ExperimentResult objects from solver result.

   Args:
       experiment_name: Name of experiment.
       solver_result: Result object from :class:`Solver.solve`.
       measurement_subsystems: Labels of subsystems in the model being measured.
       memory_slot_indices: Indices of memory slots
           to store the results in for each subsystem.
       num_memory_slots: Total number of memory slots in the returned output.
           If ``None``, ``max(memory_slot_indices)`` will be used.
       backend: The backend instance that ran the simulation.
           Various options and properties are utilized.
       seed: Seed for any random number generation involved
           (e.g. when computing outcome samples).
       metadata: Metadata to add to the header of the
           :class:`~qiskit.result.models.ExperimentResult` object.

   Returns:
       :class:`~qiskit.result.models.ExperimentResult`

   Raises:
       If a specified option is unsupported,
       then raises :py:class:`~qiskit.exceptions.QiskitError`.


.. py:class:: QiskitPulseBackend(hamiltonian: casq.models.hamiltonian_model.HamiltonianModel, control: casq.models.control_model.ControlModel, seed: Optional[int] = None)


   Bases: :py:obj:`casq.backends.pulse_backend.PulseBackend`

   QiskitPulseBackend class.

   Args:
       hamiltonian: Hamiltonian model.
       control: Control model.
       seed: Seed to use in random sampling. Defaults to None.

   .. py:method:: from_backend(backend: qiskit.providers.Backend, extracted_qubits: Optional[list[int]] = None, rotating_frame: Optional[Union[qiskit_dynamics.array.Array, qiskit_dynamics.RotatingFrame]] = None, in_frame_basis: bool = False, evaluation_mode: Optional[casq.models.hamiltonian_model.HamiltonianModel.EvaluationMode] = None, rwa_cutoff_freq: Optional[float] = None, rwa_carrier_freqs: Optional[Union[numpy.typing.NDArray, tuple[numpy.typing.NDArray, numpy.typing.NDArray]]] = None, seed: Optional[int] = None) -> Self
      :classmethod:

      Construct a QiskitPulseBackend instance from an existing backend instance.

      Args:
          backend: The ``Backend`` instance to build the :class:`.DynamicsBackend` from.
          extracted_qubits: List of qubits to extract from the Hamiltonian.
          rotating_frame: Rotating frame argument for the internal :class:`.Solver`.
                  Defaults to None, allowing this method to pick a rotating frame.
          in_frame_basis: Whether to represent the model in the basis in which
                          the rotating frame operator is diagonalized.
          evaluation_mode: Evaluation mode to use by solver.
          rwa_cutoff_freq: Rotating wave approximation cutoff frequency.
                          If None, no approximation is made.
          rwa_carrier_freqs: Carrier frequencies to use for rotating wave approximation.
          seed: Seed to use in random sampling. Defaults to None.

      Returns:
          :py:class:`casq.backends.qiskit.QiskitPulseBackend`


   .. py:method:: solve(circuit: casq.gates.pulse_circuit.PulseCircuit, method: casq.backends.pulse_backend.PulseBackend.ODESolverMethod, initial_state: Optional[Union[qiskit.quantum_info.DensityMatrix, qiskit.quantum_info.Statevector]] = None, shots: int = 1024, steps: Optional[int] = None, run_options: Optional[dict[str, Any]] = None) -> casq.backends.pulse_backend.PulseBackend.Solution

      QiskitPulseBackend.solve.

      Args:
          circuit: Pulse circuit.
          method: ODE solving method to use.
          initial_state: Initial state for simulation,
              either None,
              indicating that the ground state for the system Hamiltonian should be used,
              or an arbitrary Statevector or DensityMatrix.
          shots: Number of shots per experiment. Defaults to 1024.
          steps: Number of steps at which to solve the system.
              Used to automatically calculate an evenly-spaced t_eval range.
          run_options: Options specific to native backend's run method.

      Returns:
          :py:class:`casq.backends.PulseBackend.Solution`


   .. py:method:: _get_native_backend() -> casq.backends.qiskit.dynamics_backend_patch.DynamicsBackendPatch

      QiskitPulseBackend._get_native_backend.

      Returns:
          :py:class:`casq.backends.qiskit.DynamicsBackendPatch`



