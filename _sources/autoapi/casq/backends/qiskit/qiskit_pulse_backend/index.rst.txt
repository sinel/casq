:py:mod:`casq.backends.qiskit.qiskit_pulse_backend`
===================================================

.. py:module:: casq.backends.qiskit.qiskit_pulse_backend

.. autoapi-nested-parse::

   Pulse simulator.



Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   casq.backends.qiskit.qiskit_pulse_backend.QiskitPulseBackend




.. py:class:: QiskitPulseBackend(model: casq.models.PulseBackendModel, seed: Optional[int] = None)


   Bases: :py:obj:`casq.backends.pulse_backend.PulseBackend`

   QiskitPulseBackend class.

   .. py:method:: from_backend(backend: Union[qiskit.providers.BackendV1, qiskit.providers.BackendV2], qubits: Optional[list[int]] = None, rotating_frame: Optional[Union[qiskit_dynamics.array.Array, qiskit_dynamics.RotatingFrame]] = None, in_frame_basis: bool = False, evaluation_mode: Optional[casq.models.HamiltonianModel.EvaluationMode] = None, rwa_cutoff_freq: Optional[float] = None, rwa_carrier_freqs: Optional[Union[numpy.typing.NDArray, tuple[numpy.typing.NDArray, numpy.typing.NDArray]]] = None, seed: Optional[int] = None) -> Self
      :classmethod:

      Construct a QiskitPulseBackend instance from an existing backend instance.

      Args:
          backend: The ``Backend`` instance to build the :class:`.DynamicsBackend` from.
          qubits: List of qubits to include from the backend.
          rotating_frame: Rotating frame argument for the internal :class:`.Solver`.
                  Defaults to None, allowing this method to pick a rotating frame.
          in_frame_basis: Whether to represent the model in the basis in which
                          the rotating frame operator is diagonalized.
          evaluation_mode: Evaluation mode to use by solver.
          rwa_cutoff_freq: Rotating wave approximation cutoff frequency.
                          If None, no approximation is made.
          rwa_carrier_freqs: Carrier frequencies to use for rotating wave approximation.
          seed: Seed to use in random sampling. Defaults to None.

      Returns:
          QiskitPulseBackend


   .. py:method:: run(circuit: casq.gates.pulse_circuit.PulseCircuit, method: casq.backends.pulse_backend.PulseBackend.ODESolverMethod, initial_state: Optional[Union[qiskit.quantum_info.DensityMatrix, qiskit.quantum_info.Statevector]] = None, shots: int = 1024, steps: Optional[int] = None) -> casq.backends.pulse_solution.PulseSolution

      QiskitPulseBackend.run.


   .. py:method:: _get_native_backend() -> casq.backends.qiskit.dynamics_backend_patch.DynamicsBackendPatch

      QiskitPulseBackend._get_native_backend.



