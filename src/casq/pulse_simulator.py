#  ********************************************************************************
#
#    _________ __________ _
#   / ___/ __ `/ ___/ __ `/    Python toolkit
#  / /__/ /_/ (__  ) /_/ /     for control and analysis
#  \___/\__,_/____/\__, /      of superconducting qubits
#                    /_/
#
#  Copyright (c) 2023 Sinan Inel <sinan.inel@aalto.fi>
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
#  ********************************************************************************
"""Pulse simulator."""
from __future__ import annotations

from enum import Enum
from typing import Any, Optional, Union

from loguru import logger
from matplotlib.figure import Figure
import numpy as np
from qiskit.providers import BackendV1, BackendV2
from qiskit.pulse import Schedule
from qiskit.quantum_info import DensityMatrix, Statevector, partial_trace
from qiskit.result import Result
from qiskit.result.models import (
    ExperimentResult,
    ExperimentResultData,
    QobjExperimentHeader,
)
from qiskit_dynamics import RotatingFrame, Solver
from qiskit_dynamics.array import Array
from qiskit_dynamics.backend import DynamicsBackend

# noinspection PyProtectedMember
from qiskit_dynamics.backend.backend_utils import (
    _get_counts_from_samples,
    _get_iq_data,
    _get_memory_slot_probabilities,
    _sample_probability_dict,
)

# noinspection PyProtectedMember
from scipy.integrate._ivp.ivp import OdeResult

from casq.common import (
    PulseBackendProperties,
    CasqError,
    LegendStyle,
    LineConfig,
    LineData,
    LineStyle,
    MarkerStyle,
    plot,
    plot_bloch,
    trace,
)


class PulseSimulator(DynamicsBackend):
    """PulseSimulator class.

    This class extends :class:`~qiskit.qiskit_dynamics.DynamicsBackend`
    to provide the following improvements.
    - Solutions are calculated for each t_eval point,
        however intermediate solutions are not stored in the result object.
        This bug is now fixed.
    - t_eval must be provided without knowing the internally calculated t_span range.
        Furthermore, manually entering t_span causes an error. As a result,
        providing a t_eval range is awkward at best and error-prone.
        As an alternative, automatic calculation of t_eval range
        based on a steps argument is now provided.
    """

    class ODESolverMethod(str, Enum):
        """Solver methods."""

        QISKIT_DYNAMICS_RK4 = "RK4"
        QISKIT_DYNAMICS_JAX_RK4 = "jax_RK4"
        QISKIT_DYNAMICS_JAX_ODEINT = "jax_odeint"
        SCIPY_BDF = "BDF"
        SCIPY_DOP853 = "DOP853"
        SCIPY_LSODA = "LSODA"
        SCIPY_RADAU = "Radau"
        SCIPY_RK23 = "RK23"
        SCIPY_RK45 = "RK45"

    @staticmethod
    def plot_population(
        result: ExperimentResult,
        filename: Optional[str] = None, hidden: bool = False
    ) -> Figure:
        """PulseSimulator.plot_population method.

        Plots populations from result.

        Args:
            result: Pulse simulator result.
            filename: If filename is provided as path str, then figure is saved as png.
            hidden: If False, then plot is not displayed. Useful if method is used for saving only.

        Returns:
            :py:class:`matplotlib.figure.Figure`
        """
        if hasattr(result.data, "populations") and hasattr(result.data, "times"):
            times = result.data.times
            populations = result.data.populations
            pops: dict[str, list] = {}
            for key in populations[-1].keys():
                pops[key] = []
            for p in populations:
                for key in pops.keys():
                    value = p.get(key, 0)
                    pops[key].append(value)
            configs = []
            for key, value in pops.items():
                config = LineConfig(
                    data=LineData(times, value),
                    label=f"Population in |{key}>",
                    line_style=LineStyle(),
                    xtitle="Time (ns)",
                    ytitle="Population",
                )
                configs.append(config)
            return plot(configs=configs, legend_style=LegendStyle(), filename=filename, hidden=hidden)
        else:
            raise CasqError(
                "PulseSimulator.plot_population method requires "
                "an ExperimentResult instance generated by PulseSimulator"
            )

    @staticmethod
    def plot_iq(
        result: ExperimentResult, time_index: Optional[int] = None,
        filename: Optional[str] = None, hidden: bool = False
    ) -> Figure:
        """PulseSimulator.plot_iq method.

        Plots IQ points from result.

        Args:
            result: Pulse simulator result.
            time_index: Time at which to plot IQ points.
            filename: If filename is provided as path str, then figure is saved as png.
            hidden: If False, then plot is not displayed. Useful if method is used for saving only.

        Returns:
            :py:class:`matplotlib.figure.Figure`
        """
        if hasattr(result.data, "iq_data"):
            iq_data = result.data.iq_data
            t = time_index if time_index else -1
            x = []
            y = []
            for iq in iq_data[t]:
                x.append(iq[0][0])
                y.append(iq[0][1])
            config = LineConfig(
                data=LineData(x, y), marker_style=MarkerStyle(), xtitle="I", ytitle="Q"
            )
            return plot(configs=[config], filename=filename, hidden=hidden)
        else:
            raise CasqError(
                "PulseSimulator.plot_iq method requires "
                "an ExperimentResult instance generated by PulseSimulator"
            )

    @staticmethod
    def plot_iq_trajectory(
        result: ExperimentResult,
        filename: Optional[str] = None, hidden: bool = False
    ) -> Figure:
        """PulseSimulator.plot_iq_trajectory method.

        Plots trajectory of average IQ points from result.

        Args:
            result: Pulse simulator result.
            filename: If filename is provided as path str, then figure is saved as png.
            hidden: If False, then plot is not displayed. Useful if method is used for saving only.

        Returns:
            :py:class:`matplotlib.figure.Figure`
        """
        if hasattr(result.data, "avg_iq_data"):
            avg_iq_data = result.data.avg_iq_data
            x = []
            y = []
            for iq in avg_iq_data:
                x.append(iq[0][0])
                y.append(iq[0][1])
            config = LineConfig(
                data=LineData(x, y), marker_style=MarkerStyle(), xtitle="I", ytitle="Q"
            )
            return plot(configs=[config], filename=filename, hidden=hidden)
        else:
            raise CasqError(
                "PulseSimulator.plot_iq_trajectory method requires "
                "an ExperimentResult instance generated by PulseSimulator"
            )

    @staticmethod
    def plot_trajectory(
        result: ExperimentResult, qubit: Optional[int] = None,
        filename: Optional[str] = None, hidden: bool = False
    ) -> Figure:
        """PulseSimulator.plot_trajectory method.

        Plots statevector trajectory from result.

        Args:
            result: Pulse simulator result.
            qubit: Qubit to plot trajectory of.
            filename: If filename is provided as path str, then figure is saved as png.
            hidden: If False, then plot is not displayed. Useful if method is used for saving only.

        Returns:
            :py:class:`matplotlib.figure.Figure`
        """
        if hasattr(result.data, "qubits") and hasattr(result.data, "times"):
            times = result.data.times
            qubits = result.data.qubits
            x, y, z = PulseSimulator._xyz(result)
            if len(qubits) > 1:
                if qubit:
                    x, y, z = x[qubit], y[qubit], z[qubit]
                else:
                    raise CasqError(
                        "Cannot plot Bloch trajectory "
                        "when qubit is not specified for a multi-qubit system."
                    )
            x_config = LineConfig(
                data=LineData(times, x),
                line_style=LineStyle(),
                label="$\\langle X \\rangle$",
                xtitle="$t$",
            )
            y_config = LineConfig(
                data=LineData(times, y),
                line_style=LineStyle(),
                label="$\\langle Y \\rangle$",
                xtitle="$t$",
            )
            z_config = LineConfig(
                data=LineData(times, z),
                line_style=LineStyle(),
                label="$\\langle Z \\rangle$",
                xtitle="$t$",
            )
            return plot(
                configs=[x_config, y_config, z_config], legend_style=LegendStyle(),
                filename=filename, hidden=hidden
            )
        else:
            raise CasqError(
                "PulseSimulator.plot_trajectory method requires "
                "an ExperimentResult instance generated by PulseSimulator"
            )

    @staticmethod
    def plot_bloch_trajectory(
        result: ExperimentResult, qubit: Optional[int] = None,
        filename: Optional[str] = None, hidden: bool = False
    ) -> Figure:
        """PulseSimulator.plot_bloch_trajectory method.

        Plots statevector trajectory on Bloch sphere from result.

        Args:
            result: Pulse simulator result.
            qubit: Qubit to plot trajectory of.
            filename: If filename is provided as path str, then figure is saved as png.
            hidden: If False, then plot is not displayed. Useful if method is used for saving only.

        Returns:
            :py:class:`matplotlib.figure.Figure`
        """
        if hasattr(result.data, "qubits"):
            qubits = result.data.qubits
            x, y, z = PulseSimulator._xyz(result)
            if len(qubits) > 1:
                if qubit:
                    x, y, z = x[qubit], y[qubit], z[qubit]
                else:
                    raise CasqError(
                        "Cannot plot Bloch trajectory "
                        "when qubit is not specified for a multi-qubit system."
                    )
            return plot_bloch(x, y, z, filename=filename, hidden=hidden)
        else:
            raise CasqError(
                "PulseSimulator.plot_bloch_trajectory method requires "
                "an ExperimentResult instance generated by PulseSimulator"
            )

    @staticmethod
    def _xyz(
        result: ExperimentResult,
    ) -> Union[
        tuple[list[float], list[float], list[float]],
        tuple[dict[int, list[float]], dict[int, list[float]], dict[int, list[float]]],
    ]:
        """PulseSimulator._xyz method.

        Transforms statevectors into 3D trajectory from result.

        Args:
            result: Pulse simulator result.

        Returns:
            XYZ data lists or dict of lists.
        """
        if hasattr(result.data, "qubits") and hasattr(result.data, "statevectors"):
            statevectors = result.data.statevectors
            qubits = result.data.qubits
            if len(qubits) > 1:
                xq: dict[int, list] = {}
                yq: dict[int, list] = {}
                zq: dict[int, list] = {}
                for q in qubits:
                    xq[q] = []
                    yq[q] = []
                    zq[q] = []
                    for sv in statevectors:
                        traced_sv = PulseSimulator._trace(qubits, sv, q)
                        xp, yp, zp = traced_sv.data.real
                        xq[q].append(xp)
                        yq[q].append(yp)
                        zq[q].append(zp)
                return xq, yq, zq
            else:
                xsv: list[float] = []
                ysv: list[float] = []
                zsv: list[float] = []
                for sv in statevectors:
                    xp, yp, zp = sv.data.real
                    xsv.append(xp)
                    ysv.append(yp)
                    zsv.append(zp)
                return xsv, ysv, zsv
        else:
            raise CasqError(
                "PulseSimulator._xyz method requires "
                "an ExperimentResult instance generated by PulseSimulator"
            )

    @staticmethod
    def _trace(qubits: list[int], state: Statevector, qubit: int) -> Statevector:
        """PulseSimulator._trace method.

        Generate partial trace of statevector for specified qubit.

        Args:
            qubits: List of qubits for system.
            state: System state given as statevector.
            qubit: Qubit to trace out.

        Returns:
            Reduced statevector.
        """
        traced_over_qubits = qubits
        traced_over_qubits.remove(qubit)
        partial_density_matrix = partial_trace(state, traced_over_qubits)
        return partial_density_matrix.to_statevector()

    @staticmethod
    def get_experiment_result(
        experiment_name: str,
        solver_result: OdeResult,
        measurement_subsystems: list[int],
        memory_slot_indices: list[int],
        num_memory_slots: Union[None, int],
        backend: DynamicsBackend,
        seed: Optional[int] = None,
        metadata: Optional[dict] = None,
    ) -> ExperimentResult:
        """Generates ExperimentResult objects from solver result.

        Args:
            experiment_name: Name of experiment.
            solver_result: Result object from :class:`Solver.solve`.
            measurement_subsystems: Labels of subsystems in the model being measured.
            memory_slot_indices: Indices of memory slots
                to store the results in for each subsystem.
            num_memory_slots: Total number of memory slots in the returned output.
                If ``None``, ``max(memory_slot_indices)`` will be used.
            backend: The backend instance that ran the simulation.
                Various options and properties are utilized.
            seed: Seed for any random number generation involved
                (e.g. when computing outcome samples).
            metadata: Metadata to add to the header of the
                :class:`~qiskit.result.models.ExperimentResult` object.

        Returns:
            :class:`~qiskit.result.models.ExperimentResult`

        Raises:
            QiskitError: If a specified option is unsupported.
        """
        counts = []
        samples = []
        populations = []
        iq_data = []
        avg_iq_data = []
        quantum_states = []
        for t, y in zip(solver_result.t, solver_result.y):
            # Take state out of frame, put in dressed basis, and normalize
            if isinstance(y, Statevector):
                # noinspection PyTypeChecker
                y = np.array(
                    backend.options.solver.model.rotating_frame.state_out_of_frame(
                        t=t, y=y
                    )
                )
                y = backend._dressed_states_adjoint @ y
                y = Statevector(y, dims=backend.options.subsystem_dims)
                if backend.options.normalize_states:
                    y = y / np.linalg.norm(y.data)
            elif isinstance(y, DensityMatrix):
                # noinspection PyTypeChecker
                y = np.array(
                    backend.options.solver.model.rotating_frame.operator_out_of_frame(
                        t=t, operator=y
                    )
                )
                y = backend._dressed_states_adjoint @ y @ backend._dressed_states
                y = DensityMatrix(y, dims=backend.options.subsystem_dims)
                if backend.options.normalize_states:
                    y = y / np.diag(y.data).sum()
            else:
                y = Statevector(y, dims=backend.options.subsystem_dims)
            quantum_states.append(y)
            # compute probabilities for measurement slot values
            measurement_subsystems = [
                backend.options.subsystem_labels.index(x)
                for x in measurement_subsystems
            ]
            populations_step = _get_memory_slot_probabilities(
                probability_dict=y.probabilities_dict(qargs=measurement_subsystems),
                memory_slot_indices=memory_slot_indices,
                num_memory_slots=num_memory_slots,
                max_outcome_value=1,
            )
            populations.append(populations_step)
            # sample
            samples_step = _sample_probability_dict(
                populations_step, shots=backend.options.shots, seed=seed
            )
            samples.append(samples_step)
            counts.append(_get_counts_from_samples(samples_step))
            # Default iq_centers
            iq_centers = []
            for sub_dim in backend.options.subsystem_dims:
                theta = 2 * np.pi / sub_dim
                iq_centers.append(
                    [
                        [np.cos(idx * theta), np.sin(idx * theta)]
                        for idx in range(sub_dim)
                    ]
                )
            # generate IQ
            iq_data_step = _get_iq_data(
                y,
                measurement_subsystems=measurement_subsystems,
                iq_centers=iq_centers,
                iq_width=0.2,
                shots=backend.options.shots,
                memory_slot_indices=memory_slot_indices,
                num_memory_slots=num_memory_slots,
                seed=seed,
            )
            iq_data.append(iq_data_step)
            avg_iq_data_step = np.average(iq_data_step, axis=0)
            avg_iq_data.append(avg_iq_data_step)
        # noinspection PyTypeChecker
        data = ExperimentResultData(
            counts=counts,
            memory=samples,
            qubits=backend.options.subsystem_labels,
            times=solver_result.t,
            statevectors=quantum_states,
            populations=populations,
            iq_data=iq_data,
            avg_iq_data=avg_iq_data,
        )
        return ExperimentResult(
            shots=backend.options.shots,
            success=True,
            data=data,
            seed=seed,
            header=QobjExperimentHeader(name=experiment_name, metadata=metadata),
        )

    @classmethod
    def from_backend(
        cls,
        backend: Union[str, BackendV1, BackendV2],
        rotating_frame: Optional[Union[Array, RotatingFrame, str]] = "auto",
        evaluation_mode: str = "dense",
        rwa_cutoff_freq: Optional[float] = None,
        qubits: Optional[list[int]] = None,
        initial_state: Optional[Union[DensityMatrix, Statevector]] = None,
        method: Optional[PulseSimulator.ODESolverMethod] = None,
        steps: Optional[int] = None,
        shots: int = 1024,
        seed: Optional[int] = None,
        solver_options: Optional[dict[str, Any]] = None,
    ) -> PulseSimulator:
        """Construct a PulseSimulator instance from an existing Backend instance.

        Args:
            backend: The ``Backend`` instance to build the :class:`.PulseSimulator` from.
            rotating_frame: Rotating frame argument for the internal :class:`.Solver`. Defaults to
                ``"auto"``, allowing this method to pick a rotating frame.
            evaluation_mode: Evaluation mode argument for the internal :class:`.Solver`.
            rwa_cutoff_freq: Rotating wave approximation argument for the internal :class:`.Solver`.
            qubits: Integer labels for selected qubits from system. Defaults to [0].
            initial_state: Initial state for simulation, an arbitrary Statevector or DensityMatrix.
                If None, then defaults to the ground state for the system Hamiltonian.
            method: ODE solver method.
            steps: Number of steps at which to solve the system.
                Used to automatically calculate an evenly-spaced t_eval range.
            shots: Number of shots per experiment. Defaults to 1024.
            seed: Seed to use in random sampling. Defaults to None.
            solver_options: Dictionary containing optional kwargs for passing to Solver.solve().
                Defaults to the empty dictionary {}.

        Returns:
            PulseSimulator
        """
        if isinstance(backend, str):
            backend = PulseBackendProperties.get_backend(backend)
        if method:
            if solver_options:
                solver_options.update(method=method.value)
            else:
                solver_options = {"method": method.value}
        dynamics_backend = DynamicsBackend.from_backend(
            backend,
            subsystem_list=qubits,
            rotating_frame=rotating_frame,
            evaluation_mode=evaluation_mode,
            rwa_cutoff_freq=rwa_cutoff_freq,
            solver_options=solver_options,
        )
        simulator: PulseSimulator = PulseSimulator(
            solver=dynamics_backend.options.solver,
            qubits=qubits,
            initial_state=initial_state,
            method=method,
            steps=steps,
            shots=shots,
            seed=seed,
            solver_options=solver_options,
            backend=backend,
        )
        return simulator

    @trace()
    def __init__(
        self,
        solver: Solver,
        qubits: Optional[list[int]] = None,
        initial_state: Optional[Union[DensityMatrix, Statevector]] = None,
        method: Optional[PulseSimulator.ODESolverMethod] = None,
        steps: Optional[int] = None,
        shots: int = 1024,
        seed: Optional[int] = None,
        solver_options: Optional[dict[str, Any]] = None,
        backend: Optional[BackendV1] = None,
    ):
        """Instantiate :class:`~casq.PulseSimulator`.

        Extends instantiation of :class:`~qiskit.qiskit_dynamics.DynamicsBackend`
        with additional 'steps' argument.

        Args:
            solver: Solver instance configured for pulse simulation.
            qubits: Integer labels for selected qubits from system. Defaults to [0].
            initial_state: Initial state for simulation, an arbitrary Statevector or DensityMatrix.
                If None, then defaults to the ground state for the system Hamiltonian.
            method: ODE solver method.
            steps: Number of steps at which to solve the system.
                Used to automatically calculate an evenly-spaced t_eval range.
            shots: Number of shots per experiment. Defaults to 1024.
            seed: Seed to use in random sampling. Defaults to None.
            solver_options: Dictionary containing optional kwargs for passing to Solver.solve().
                Defaults to the empty dictionary {}.
            backend: Optional backend used to construct simulator.

        Raises:
            QiskitError: If any instantiation arguments fail validation checks.
        """
        if qubits is None:
            qubits = [0]
        if initial_state is None:
            initial_state = "ground_state"
        if solver_options:
            if method is not None:
                solver_options.update(method=method.value)
        else:
            if method is None:
                solver_options = {}
            else:
                solver_options = {"method": method.value}
        super().__init__(
            solver=solver,
            target=None,
            subsystem_labels=qubits,
            initial_state=initial_state,
            shots=shots,
            seed_simulator=seed,
            solver_options=solver_options,
            experiment_result_function=PulseSimulator.get_experiment_result,
        )
        self.solver = solver
        self.qubits = qubits
        self.initial_state = initial_state
        self.method = method
        self.steps = steps
        self.shots = shots
        self.seed = seed
        self.backend = backend

    def _run(
        self,
        job_id: str,
        t_span: Union[list[tuple[float, float]], list[list[float]]],
        schedules: list[Schedule],
        measurement_subsystems_list: list[list[int]],
        memory_slot_indices_list: list[list[int]],
        num_memory_slots_list: list[int],
    ) -> Result:
        """Run a list of simulations.

        Args:
            job_id: Job identifier.
            t_span: Tuple or list of initial and final time.
            schedules: List of schedules.
            measurement_subsystems_list: List of measurement subsystems.
            memory_slot_indices_list: List of memory slot indices.
            num_memory_slots_list: List of numbers of memory slots.

        Returns:
            ExperimentResult object.
        """
        auto_t_eval = None
        if self.steps:
            auto_t_eval = np.linspace(t_span[0][0], t_span[0][1], self.steps)
            auto_t_eval[0] = t_span[0][0]
            auto_t_eval[-1] = t_span[0][1]
        if "solver_options" in self.options:
            t_eval = self.options.solver_options.get("t_eval", None)
            if t_eval is None:
                self.options.solver_options["t_eval"] = auto_t_eval
            else:
                self.options.solver_options["t_eval"] = t_eval
        else:
            self.options.solver_options = {"t_eval": auto_t_eval}
        logger.debug(f"t_eval = {self.options.solver_options['t_eval']}")
        return super()._run(
            job_id,
            t_span,
            schedules,
            measurement_subsystems_list,
            memory_slot_indices_list,
            num_memory_slots_list,
        )
